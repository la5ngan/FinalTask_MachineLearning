# -*- coding: utf-8 -*-
"""1301174432.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NkC_wR7TyTWdOzzuCNJrNn7Gd0nkmFg0
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from pandas import DataFrame
import numpy as np
import seaborn as sns
# %matplotlib inline

#membaca file csv
url = 'https://raw.githubusercontent.com/la5ngan/FinalTask_MachineLearning/master/used_cars.csv'
used_cars = pd.read_csv(url)
# used_cars

#printcsv
used_cars

"""Memilih Kolom, di sini saya hanya mengambil 3 kolom saja"""

#membaca file csv, hanya dengan mengambil 3 kolom yaitu: fuel, odometer, dan paint_color
df = pd.read_csv(url,usecols =['fuel', 'odometer','paint_color'])
df.head(10)

#cek kondisi apakah ada null atau tidak
df.isnull().sum()

#Drop NaN / null
df.dropna(inplace=True)
df.reset_index(drop=True, inplace=True)
df

#lalu cek type nya
df.dtypes

"""Merubah type nilai data object menjadi angka"""

#berhubung ada data yang nilainya object, maka dilakukan cek isi data dari paint_color dan fuel untuk diubah menjadi angka
sns.relplot('odometer', 'fuel', data=used_cars, hue='paint_color');
sns.relplot('odometer', 'paint_color', data=used_cars, hue='fuel');

#me-replace type object ke angka                    
df['fuel'] = df['fuel'].replace({'gas': 1, 
    'diesel': 2, 
    'electric': 3, 
    'hybrid': 4,
    'other': 5,})
df['paint_color'] = df['paint_color'].replace({'black': 1, 
    'white': 2, 
    'silver': 3, 
    'brown': 4, 
    'blue': 5, 
    'grey':6,
    'red':7,
    'custom':8,
    'purple':9,
    'yellow':10,
    'green':11,
    'orange':12})

#cek type nya
df.dtypes

# df
sns.pairplot(df,hue="fuel")
# df.head()
# # df.loc[:, ~df.columns.str.match('Unnamed')]

#Ubah type semua type data ke int64
df['odometer'] = df['odometer'].astype(np.int64)
df.dtypes

x = df.drop(['fuel'], axis = 1)
y = df['fuel']
print(x.shape)
print(y.shape)

#Menentukan data test dan data training
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 20)
print ('The size of our training "X" (input features) is', x_train.shape)
print ('The size of our testing "X" (input features) is', x_test.shape)
print ('The size of our training "y" (output feature) is', y_train.shape)
print ('The size of our testing "y" (output features) is', y_test.shape)
# df.loc[:, ~df.columns.str.match('Unnamed')]

x_train.shape

x_test.shape

# df_clustering = pd.DataFrame(x_train, columns=['odometer', 'paint_color'])
# df_clustering['cluster'] = y_train
# df_clustering
# sns.scatterplot(x='paint_color', y='odometer', hue='cluster', data=df_clustering)

"""CLUSTERING"""

#Memakai elbow method
from sklearn.cluster import KMeans
uc =[]
for i in range (1,11):
    kmeans = KMeans(n_clusters = i, init = 'k-means++', max_iter =300, n_init = 10, random_state = 0)
    kmeans.fit(df)
    uc.append(kmeans.inertia_)

plt.plot(range(1,11),uc)
plt.title('Used Cars')
plt.xlabel('K') #K = jumlah centroid
plt.ylabel('SSE') # untuk evaluasi
plt.show()

#melihat range data
print(df.groupby('paint_color').size())
print(df.groupby('odometer').size())

import random

#inisialisasi K
k=3

centroids = {
    i+1: [np.random.randint(1,12), np.random.randint(0,2500005)]
    for i in range(3)
}

fig = plt.figure(figsize=(5, 5))
plt.scatter(df['paint_color'], df['odometer'], color='k')
colmap = {1: 'r', 2: 'g', 3: 'b'}
for i in centroids.keys():
  plt.scatter(*centroids[i], color=colmap[i])
plt.show()

#assignment stage

def assignment(df, centroids):
  for i in centroids.keys():
    #sqrt ((x1-x2)^2 - (y1-y2)^2)
    df['distance_from_{}'.format(i)] = (
        np.sqrt(
            (df['paint_color'] - centroids[i][0]) ** 2 + (df['odometer'] - centroids[i][1]) ** 2
        )
    )
  centroid_distance_cols = ['distance_from_{}'.format(i) for i in centroids.keys()]
  df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis=1)
  df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_')))
  df['color'] = df['closest'].map(lambda x: colmap[x])
  return df

df = assignment(df, centroids)
print(df.head())

fig = plt.figure(figsize=(5, 5))
plt.scatter(df['paint_color'], df['odometer'], alpha=0.5, edgecolor='k')
for i in centroids.keys():
  plt.scatter(*centroids[i], color=colmap[i])
plt.show()

#Update Stage
import copy

old_centroids = copy.deepcopy(centroids)

def update(k):
  for i in centroids.keys():
    centroids[i][0] = np.mean(df[df['closest'] == i]['paint_color'])
    centroids[i][1] = np.mean(df[df['closest'] == i]['odometer'])
  return k

centroids = update(centroids)

fig = plt.figure(figsize=(5,5))
ax = plt.axes()
plt.scatter(df['paint_color'], df['odometer'], color=df['color'], alpha = 0.5, edgecolor='k')
for i in centroids.keys():
  plt.scatter(*centroids[i], color=colmap[i])

plt.show()

#Repeat Assignment Stage

df = assignment(df, centroids)

#Plot results
fig = plt.figure(figsize=(5,5))
plt.scatter(df['paint_color'], df['odometer'], color = df['color'], alpha = 0.5, edgecolor='k')
for i in centroids.keys():
  plt.scatter(*centroids[i], color=colmap[i])
plt.show()

#Continue until all assigned categories don't change any more
while True:
  closest_centroids = df['closest'].copy(deep=True)
  centroids = update(centroids)
  df = assignment(df, centroids)
  if closest_centroids.equals(df['closest']):
    break

fig = plt.figure(figsize=(5,5))
plt.scatter(df['paint_color'], df['odometer'], color = df['color'], alpha = 0.5, edgecolor='k')
for i in centroids.keys():
  plt.scatter(*centroids[i], color=colmap[i])
plt.show()

idxup = df[(df['paint_color'] >df['paint_color'].quantile(0.9))].index
idxbot = df[(df['paint_color'] < df['paint_color'].quantile(0.1))].index

df = df.drop(idxup)
df = df.drop(idxbot)

idxupp = df[(df['odometer'] > df['odometer'].quantile(0.9))].index
idxbott = df[(df['odometer'] < df['odometer'].quantile(0.1))].index

df = df.drop(idxupp)
df = df.drop(idxbott)

df.head()

"""CLASSIFICATION"""

from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
svc_model = SVC()
svc_model.fit(x_train, y_train)
y_predict = svc_model.predict(x_test)

from sklearn.metrics import classification_report, confusion_matrix
cm = np.array(confusion_matrix(y_test, y_predict, labels=[1,0]))
confusion = pd.DataFrame(cm, index=['actual yes', 'actual no'],
                         columns=['predicted yes','predicted no'])
confusion

print(classification_report(y_test, y_predict))

from sklearn.neighbors import KNeighborsClassifier
neigh = KNeighborsClassifier(n_neighbors=3)
neigh.fit(x_train,y_train)
y_predict = neigh.predict(x_test)
accuracy_score(y_test,y_predict)
print(classification_report(y_test, y_predict))

# from sklearn.neighbors import KNeighborsClassifier
# classifier = KNeighborsClassifier(n_neighbors = 5)
# classifier.fit(x_train, y_train)

# y_pred = classifier.predict(x_test)

# from sklearn.metrics import confusion_matrix
# labels = ['y_test', 'y_pred']
# cm = confusion_matrix(y_test, y_pred)
# print(cm)
# fig = plt.figure()
# ax = fig.add_subplot(111)
# cax = ax.matshow(cm)
# plt.title('Confusion matrix of the classifier')
# fig.colorbar(cax)
# ax.set_xticklabels([''] + labels)
# ax.set_yticklabels([''] + labels)
# plt.xlabel('Predicted')
# plt.ylabel('True')
# plt.show()

# accuracy = classifier.score(x_test, y_test)
# print("Test Accuracy: ", accuracy)
# accuracy = classifier.score(x_train, y_train)
# print("Train Accuracy: ", accuracy)

# # Visualising the Training set results
# from matplotlib.colors import ListedColormap
# x_set, y_set = x_train, y_train
# X1, X2 = np.meshgrid(np.arange(start = x_set[:, 0].min() - 1, stop = x_set[:, 0].max() + 1, step = 0.01), np.arange(start = x_set[:, 1].min() - 1, stop = x_set[:, 1].max() + 1, step = 0.01))
# plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape), alpha = 0.75, cmap = ListedColormap(('red', 'green')))
# plt.xlim(X1.min(), X1.max())
# plt.ylim(X2.min(), X2.max())
# for i, j in enumerate(np.unique(y_set)):
#     plt.scatter(x_set[y_set == j, 0], x_set[y_set == j, 1],
#                 c = ListedColormap(('red', 'green'))(i), label = j)
# plt.title('KNN (Training set)')
# plt.xlabel('Age')
# plt.ylabel('Estimated Salary')
# plt.legend()
# plt.show()

# # Visualising the Test set results
# X_set, y_set = X_test, y_test
# X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
#                      np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
# plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
#              alpha = 0.75, cmap = ListedColormap(('red', 'green')))
# plt.xlim(X1.min(), X1.max())
# plt.ylim(X2.min(), X2.max())
# for i, j in enumerate(np.unique(y_set)):
#     plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
#                 c = ListedColormap(('red', 'green'))(i), label = j)
# plt.title('KNN (Test set)')
# plt.xlabel('Age')
# plt.ylabel('Estimated Salary')
# plt.legend()
# plt.show()